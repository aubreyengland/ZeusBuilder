import logging
from zeus import registry
from typing import Any, List, Dict, Protocol
from pydantic import ValidationError
from .upload_service import UploadSvc
from zeus.exceptions import extract_first_validation_error

log = logging.getLogger(__name__)


class SvcResponse:
    """
    Returned by SvcClient to provide status of executed service
    and any values or error messages generated by the service
    """

    def __init__(self, message, value, result):
        self.value: Any = value
        self.message: str = message
        self.result: str = result or "Success"
        self.ok: bool = True


class SuccessResponse(SvcResponse):
    def __init__(self, message="", value="", result=""):
        result = result or "Success"
        super().__init__(message, value, result)
        self.ok = True


class FailureResponse(SvcResponse):
    def __init__(self, message, value="", result=""):
        result = result or "Fail"
        super().__init__(message, value, result)
        self.ok = False


class SvcClient:
    """
    Base client class to run tool-based services
    and return responses.

    Does the following when a service method is invoked:
    - Creates an instance of the API client (if necessary)
    - Creates an instance of the appropriate Svc class
    - Call the Svc.run() method
    - Builds a SuccessResponse with the svc return value (if any)
      or catches any exceptions and builds a FailureResponse with
      an error message
    - Returns the response

    Subclasses must override the following class attributes:
        tool: Tool name (five9, wxcc, etc.)
        client_cls: API client object for the tool
    """

    tool = ""
    client_cls = None

    def upload(self, fh, **kwargs) -> SvcResponse:
        """
        Run the upload service and return the response.

        Args:
            fh (BytesIO): Uploaded workbook file handle

        Returns:
            (SvcResponse): SuccessResponse or FailureResponse
        """
        svc = UploadSvc(self.tool, fh, **kwargs)
        return self._run_svc(svc)

    def browse(self, credentials: dict, data_type: str, **kwargs):
        try:
            svc_cls = registry.get_browse_service(self.tool, data_type)
        except LookupError:
            resp = FailureResponse(f"No browse service found for '{data_type}'")

        else:
            svc = svc_cls(self.client(credentials))
            resp = self._run_svc(svc)

        return resp

    def export(self, credentials: dict, data_type: str, **kwargs):
        try:
            svc_cls = registry.get_export_service(self.tool, data_type)
        except LookupError:
            resp = FailureResponse(f"No export service found for '{data_type}'")

        else:
            svc = svc_cls(self.client(credentials))
            resp = self._run_svc(svc)

        return resp

    def bulk(self, credentials: dict, model, **kwargs) -> SvcResponse:
        data_type = model.schema()["data_type"]
        try:
            svc_cls = registry.get_bulk_service(self.tool, data_type, model.action)

        except LookupError:
            if getattr(model, "action", "") == "IGNORE":
                resp = SuccessResponse(result="Ignore")
            else:
                resp = FailureResponse(f"No bulk service found for '{data_type}'")

        else:
            svc = svc_cls(self.client(credentials), model, **kwargs)
            resp = self._run_svc(svc)
            if not resp.ok:
                self._rollback_svc(svc)

        return resp

    def detail(self, credentials: dict, data_type: str, browse_row: dict, **kwargs):
        try:
            svc_cls = registry.get_detail_service(self.tool, data_type)
        except LookupError:
            resp = FailureResponse(f"No detail task found for '{data_type}'")

        else:
            svc = svc_cls(self.client(credentials), browse_row=browse_row)
            resp = self._run_svc(svc)

        return resp

    def client(self, credentials):
        return self.client_cls(**credentials)

    @staticmethod
    def _run_svc(svc, *args, **kwargs):
        svc_name = type(svc).__name__
        log.info(f"Begin service: {svc_name} run")

        try:
            rv = svc.run()
            return SuccessResponse(value=rv)

        except ValidationError as exc:
            message = f"Validation Failed: {extract_first_validation_error(exc)}"
            log.info(f"End service: {svc_name} run: Error: {message}")
            return FailureResponse(message=message)

        except Exception as exc:
            if hasattr(exc, "message"):
                # Zeus or API client exception
                message = exc.message
                log.error(f"End service: {svc_name} run: Error: {message}")
            else:
                message = f"Unhandled Exception: {exc}"
                log.exception(f"End service: {svc_name} run: Error: {message}")

            return FailureResponse(message=message)

    @staticmethod
    def _rollback_svc(svc):
        svc_name = type(svc).__name__
        log.info(f"Begin service {svc_name} rollback")

        try:
            svc.rollback()
            log.info(f"End service: {svc_name} rollback: Ok")
        except Exception as exc:
            log.exception(f"End service: {svc_name} rollback: {exc}")


class BulkSvc:
    """
    Bulk Service base class.

    Subclasses must override the run method to execute
    the operation logic.

    Subclasses may override the rollback method if the
    default logic is not sufficient.

    A BulkSvc class should be defined for each support bulk action/data type
    combination and added to the SvcRegistry using the bulk_service
    decorator. Ex:

    ```
    @reg.bulk_service("tool", "data_type", "CREATE")
    class ToolDataTypeCreateBulkSvc(BulkSvc):
    ...

    @reg.bulk_service("tool", "data_type", "UPDATE")
    class ToolDataTypeUpdateBulkSvc(BulkSvc):
    ...

    @reg.bulk_service("tool", "data_type", "DELETE")
    class ToolDataTypeDeleteBulkSvc(BulkSvc):
    ...
    ```

    Attributes:
         client: The tool's API client authenticated for the current org
         model (DataTypeBase): data type model with workbook row data
         current (dict): Stores the 'current' details of the object
          from a GET request
        rollback_tasks (list): BulkTask instances successfully ran by the service
         that will be rolled-back if an exception is raised

     and return None if successful or
    raise a
    """

    def __init__(self, client, model, **kwargs):
        self.client = client
        self.model = model
        self.current: dict = {}
        self.rollback_tasks: List[BulkTask] = []

    def run(self) -> None:
        """
        Executes the operation logic to complete the operation for the
        provided data type model.

        Saves state necessary for the rollback method.

        Returns:
            None if successful

        Raises:
            ZeusBulkOpFailed if operation is unsuccessful
        """
        return None

    def rollback(self) -> None:
        """
        Executes logic to reset values to their original state when
        a bulk operation fails.

        The base method logic is to call rollback on each successful task
        in reverse order.

        Returns:
            None if successful
        """
        for task in reversed(self.rollback_tasks):
            task.rollback()


class BulkTask:
    """
    Bulk Task base class.

    Responsible for performing a single (or small number) of
    create/update API requests and storing the necessary information
    to roll the changes back if necessary.

    The run method must be overridden to implement the task logic.
    The rollback method must be overridden if rollback is possible.

    Attributes:
        svc (BulkSvc): BulkSvc instance that initiated the task
        model (DataTypeBase): data type model with workbook row data
        client: The tool's API client authenticated for the current org
    """

    def __init__(self, svc, **kwargs):
        self.svc: BulkSvc = svc
        self.model = svc.model
        self.client = svc.client

    def run(self) -> Any:
        """
        Executes the create/update API request(s) and stores information
        to roll back the change if necessary.

        Returns:
            May have a return value if it makes sense in the context
            of the bulk service
        """
        pass

    def rollback(self) -> None:
        """
        Executes the API request(s) to restore an object to the
        state before the task ran

        Returns:
            None
        """
        pass


class BrowseSvc:
    """
    Browse Service base class.

    Gets objects for a specific data type in order to build the browse table.

    A BrowseSvc class should be defined for each data type that supports
    the browse operation and added to the SvcRegistry using the browse_service
    decorator. Ex:

    ```
    @reg.browse_service("tool", "data_type")
    class ToolDataTypeBrowseSvc(BrowseSvc):
    ...
    ```

    Attributes:
        client: The tool's API client authenticated for the current org
    """

    def __init__(self, client, **kwargs):
        self.client = client

    def run(self) -> List[dict]:
        """
        Make API requests to get objects of a specific data type.
        Validate the API responses through the data type's data type model.

        Returns:
            (list): List of data type model instances converted to dictionaries
        """
        pass


class DetailSvc:
    """
    Detail Service base class.

    Gets additional info for a single object in a browse table.

    A DetailSvc class should be defined for each data type that supports
    the detail operation and added to the SvcRegistry using the detail_service
    decorator. Ex:

    ```
    @reg.detail_service("tool", "data_type")
    class ToolDataTypeDetailSvc(DetailSvc):
    ...
    ```

    Attributes:
        client: The tool's API client authenticated for the current org
        browse_row (dict): Data from the selected browse table row
    """

    def __init__(self, client, browse_row):
        self.client = client
        self.browse_row: dict = browse_row

    def run(self) -> dict:
        """
        Make API requests to get details for the object identified by
        the detail_id.
        Validate the API responses through the data type's data type model.

        Returns:
            (dict): data_type model instance converted to a dictionary
        """
        pass


class ExportSvc:
    """
    Export Service base class.

    Gets data from the API to populate all data type model fields in order to
    create a complete provisioning workbook.

    An ExportSvc class should be defined for each data type that supports
    the export operation and added to the SvcRegistry using the export_service
    decorator. Ex:

    ```
    @reg.export_service("tool", "data_type")
    class ToolDataTypeExportSvc(ExportSvc):
    ...
    ```

    Attributes:
        client: The tool's API client authenticated for the current org
    """

    def __init__(self, client, **kwargs):
        self.client = client

    def run(self) -> Dict[str, dict]:
        """
        Make API requests to build complete data type models for all objects
        of a specific data type.

        Validate the responses through the data type's model.

        Returns:
            (dict): Key: data type name.
                    Value: List of dictionaries created by the model's
                    `to_wb` method
        """
        pass
